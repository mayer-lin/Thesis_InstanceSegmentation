<html>
<head>
<title>Optimization_submitted.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Optimization_submitted.py</font>
</center></td></tr></table>
<pre><span class="s0">###################################################################################################</span>
<span class="s0">###### This script optimizes the parameters of a watershed / morpholigical image segmentation ######</span>
<span class="s0">###################################################################################################</span>


<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">rasterio</span>
<span class="s2">import </span><span class="s1">geopandas </span><span class="s2">as </span><span class="s1">gpd</span>
<span class="s2">import </span><span class="s1">optuna</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">ndimage </span><span class="s2">as </span><span class="s1">ndi</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize </span><span class="s2">import </span><span class="s1">linear_sum_assignment</span>
<span class="s2">from </span><span class="s1">skimage </span><span class="s2">import </span><span class="s1">filters</span><span class="s3">, </span><span class="s1">morphology</span>
<span class="s2">from </span><span class="s1">skimage</span><span class="s3">.</span><span class="s1">filters </span><span class="s2">import </span><span class="s1">sobel</span>
<span class="s2">from </span><span class="s1">skimage</span><span class="s3">.</span><span class="s1">feature </span><span class="s2">import </span><span class="s1">peak_local_max</span>
<span class="s2">from </span><span class="s1">skimage</span><span class="s3">.</span><span class="s1">segmentation </span><span class="s2">import </span><span class="s1">watershed</span>
<span class="s2">from </span><span class="s1">skimage</span><span class="s3">.</span><span class="s1">morphology </span><span class="s2">import </span><span class="s1">disk</span><span class="s3">, </span><span class="s1">dilation</span><span class="s3">, </span><span class="s1">h_minima</span>
<span class="s2">from </span><span class="s1">skimage</span><span class="s3">.</span><span class="s1">measure </span><span class="s2">import </span><span class="s1">regionprops</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">metrics </span><span class="s2">import </span><span class="s1">pairwise_distances</span>
<span class="s2">from </span><span class="s1">tqdm </span><span class="s2">import </span><span class="s1">tqdm</span>

<span class="s0"># Set Directories</span>
<span class="s1">base_dir </span><span class="s3">= </span><span class="s1">Path</span><span class="s3">(</span><span class="s4">&quot;data/input&quot;</span><span class="s3">)</span>
<span class="s1">raster_dir </span><span class="s3">= </span><span class="s1">Path</span><span class="s3">(</span><span class="s4">&quot;data/input&quot;</span><span class="s3">)</span>
<span class="s1">ground_truth_dir </span><span class="s3">= </span><span class="s1">Path</span><span class="s3">(</span><span class="s4">&quot;data/input&quot;</span><span class="s3">)</span>

<span class="s0"># Define batch files</span>
<span class="s1">batch_files </span><span class="s3">= [</span>
  <span class="s3">(</span><span class="s1">raster_dir </span><span class="s3">/ </span><span class="s4">f&quot;selectclumps_batch</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">.tif&quot;</span><span class="s3">, </span><span class="s1">ground_truth_dir </span><span class="s3">/ </span><span class="s4">f&quot;centroid_batch</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">.shp&quot;</span><span class="s3">)</span>
  <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">31</span><span class="s3">) </span><span class="s0"># Adjust range as needed. This is in accordance with the batches you created with the R script. Centroids were created in QGIS.</span>
<span class="s3">]</span>

<span class="s0"># Load raster data. Downscale as needed.</span>
<span class="s2">def </span><span class="s1">load_raster</span><span class="s3">(</span><span class="s1">raster_path</span><span class="s3">, </span><span class="s1">downscale_factor</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s2">with </span><span class="s1">rasterio</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">raster_path</span><span class="s3">) </span><span class="s2">as </span><span class="s1">src</span><span class="s3">:</span>
        <span class="s1">nodata </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">nodata</span>
        <span class="s1">new_h </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">height </span><span class="s3">// </span><span class="s1">downscale_factor </span><span class="s2">if </span><span class="s1">downscale_factor </span><span class="s2">else </span><span class="s1">src</span><span class="s3">.</span><span class="s1">height</span>
        <span class="s1">new_w </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">width </span><span class="s3">// </span><span class="s1">downscale_factor </span><span class="s2">if </span><span class="s1">downscale_factor </span><span class="s2">else </span><span class="s1">src</span><span class="s3">.</span><span class="s1">width</span>
        <span class="s1">transform </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">* </span><span class="s1">src</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">.</span><span class="s1">scale</span><span class="s3">(</span><span class="s1">src</span><span class="s3">.</span><span class="s1">width </span><span class="s3">/ </span><span class="s1">new_w</span><span class="s3">, </span><span class="s1">src</span><span class="s3">.</span><span class="s1">height </span><span class="s3">/ </span><span class="s1">new_h</span><span class="s3">)</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">out_shape</span><span class="s3">=(</span><span class="s1">new_h</span><span class="s3">, </span><span class="s1">new_w</span><span class="s3">), </span><span class="s1">resampling</span><span class="s3">=</span><span class="s1">rasterio</span><span class="s3">.</span><span class="s1">enums</span><span class="s3">.</span><span class="s1">Resampling</span><span class="s3">.</span><span class="s1">average</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">data</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">, </span><span class="s1">nodata</span>

<span class="s0"># Load and prepare ground truth data</span>
<span class="s2">def </span><span class="s1">load_ground_truth</span><span class="s3">(</span><span class="s1">shapefile</span><span class="s3">, </span><span class="s1">reference_raster</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">shapefile</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">() </span><span class="s2">or not </span><span class="s1">reference_raster</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">():</span>
        <span class="s2">return None</span>
    <span class="s2">with </span><span class="s1">rasterio</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">reference_raster</span><span class="s3">) </span><span class="s2">as </span><span class="s1">src</span><span class="s3">:</span>
        <span class="s1">crs </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">crs</span>
    <span class="s1">gdf </span><span class="s3">= </span><span class="s1">gpd</span><span class="s3">.</span><span class="s1">read_file</span><span class="s3">(</span><span class="s1">shapefile</span><span class="s3">).</span><span class="s1">to_crs</span><span class="s3">(</span><span class="s1">crs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([(</span><span class="s1">pt</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">pt</span><span class="s3">.</span><span class="s1">y</span><span class="s3">) </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">gdf</span><span class="s3">.</span><span class="s1">geometry </span><span class="s2">if </span><span class="s1">pt</span><span class="s3">.</span><span class="s1">geom_type </span><span class="s3">== </span><span class="s4">&quot;Point&quot;</span><span class="s3">])</span>

<span class="s0"># Apply segmentation</span>
<span class="s2">def </span><span class="s1">apply_segmentation</span><span class="s3">(</span><span class="s1">raster_path</span><span class="s3">, </span><span class="s1">gamma</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">threshold_type</span><span class="s3">, </span><span class="s1">erosion_disk</span><span class="s3">, </span><span class="s1">dilation_disk</span><span class="s3">, </span><span class="s1">min_dist_frac</span><span class="s3">, </span><span class="s1">h_minima_frac</span><span class="s3">):</span>
    <span class="s1">elevation</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">, </span><span class="s1">nodata </span><span class="s3">= </span><span class="s1">load_raster</span><span class="s3">(</span><span class="s1">raster_path</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">nodata </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">elevation </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">elevation </span><span class="s3">== </span><span class="s1">nodata</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">elevation</span><span class="s3">)</span>
    <span class="s1">elevation </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmin</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">))</span>
    <span class="s1">elevation </span><span class="s3">= (</span><span class="s1">elevation </span><span class="s3">- </span><span class="s1">elevation</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()) / (</span><span class="s1">elevation</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() - </span><span class="s1">elevation</span><span class="s3">.</span><span class="s1">min</span><span class="s3">())</span>
    <span class="s1">elevation </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">, </span><span class="s1">gamma</span><span class="s3">)</span>
    <span class="s1">elevation </span><span class="s3">= </span><span class="s1">ndi</span><span class="s3">.</span><span class="s1">gaussian_filter</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">=</span><span class="s1">sigma</span><span class="s3">)</span>
    <span class="s1">gradient </span><span class="s3">= </span><span class="s1">sobel</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">)</span>
    <span class="s1">thresh </span><span class="s3">= </span><span class="s1">filters</span><span class="s3">.</span><span class="s1">threshold_otsu</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">) </span><span class="s2">if </span><span class="s1">threshold_type </span><span class="s3">== </span><span class="s4">&quot;otsu&quot; </span><span class="s2">else </span><span class="s1">filters</span><span class="s3">.</span><span class="s1">threshold_li</span><span class="s3">(</span><span class="s1">elevation</span><span class="s3">)</span>
    <span class="s1">binary </span><span class="s3">= </span><span class="s1">elevation </span><span class="s3">&gt; </span><span class="s1">thresh</span>
    <span class="s1">binary </span><span class="s3">= </span><span class="s1">morphology</span><span class="s3">.</span><span class="s1">erosion</span><span class="s3">(</span><span class="s1">binary</span><span class="s3">, </span><span class="s1">disk</span><span class="s3">(</span><span class="s1">erosion_disk</span><span class="s3">))</span>
    <span class="s1">distance </span><span class="s3">= </span><span class="s1">ndi</span><span class="s3">.</span><span class="s1">distance_transform_edt</span><span class="s3">(</span><span class="s1">binary </span><span class="s3">* </span><span class="s1">gradient</span><span class="s3">)</span>
    <span class="s1">min_dist </span><span class="s3">= </span><span class="s1">min_dist_frac </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">distance</span><span class="s3">)</span>
    <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peak_local_max</span><span class="s3">(</span><span class="s1">distance</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)), </span><span class="s1">labels</span><span class="s3">=</span><span class="s1">binary</span><span class="s3">)</span>
    <span class="s1">filtered </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">distance</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">peaks</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)] &gt; </span><span class="s1">min_dist</span><span class="s3">]</span>
    <span class="s1">markers </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">distance</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">markers</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">filtered</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)] = </span><span class="s2">True</span>
    <span class="s1">markers </span><span class="s3">= </span><span class="s1">dilation</span><span class="s3">(</span><span class="s1">markers</span><span class="s3">, </span><span class="s1">disk</span><span class="s3">(</span><span class="s1">dilation_disk</span><span class="s3">))</span>
    <span class="s1">markers</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">ndi</span><span class="s3">.</span><span class="s1">label</span><span class="s3">(</span><span class="s1">markers</span><span class="s3">)</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">watershed</span><span class="s3">(-</span><span class="s1">distance</span><span class="s3">, </span><span class="s1">markers</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">binary</span><span class="s3">)</span>
    <span class="s1">h_min </span><span class="s3">= </span><span class="s1">h_minima</span><span class="s3">(-</span><span class="s1">distance</span><span class="s3">, </span><span class="s1">h_minima_frac </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">distance</span><span class="s3">))</span>
    <span class="s1">hwt_markers</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">ndi</span><span class="s3">.</span><span class="s1">label</span><span class="s3">(</span><span class="s1">h_min</span><span class="s3">)</span>
    <span class="s1">labels_hwt </span><span class="s3">= </span><span class="s1">watershed</span><span class="s3">(-</span><span class="s1">distance</span><span class="s3">, </span><span class="s1">hwt_markers</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">binary</span><span class="s3">)</span>
    <span class="s1">centroids </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">region</span><span class="s3">.</span><span class="s1">centroid </span><span class="s2">for </span><span class="s1">region </span><span class="s2">in </span><span class="s1">regionprops</span><span class="s3">(</span><span class="s1">labels_hwt</span><span class="s3">)])</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">rasterio</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">.</span><span class="s1">xy</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">y</span><span class="s3">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">centroids</span><span class="s3">])</span>

<span class="s0"># Use the Hungarian algorithm to match detected Centroids. Adjust buffer as needed.</span>
<span class="s2">def </span><span class="s1">compute_global_iou</span><span class="s3">(</span><span class="s1">gt_centroids_list</span><span class="s3">, </span><span class="s1">detected_centroids_list</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">, </span><span class="s1">buffer_radius</span><span class="s3">=</span><span class="s5">49</span><span class="s3">): </span><span class="s0"># Buffer value currently in pixels.</span>
    <span class="s1">all_gt_world </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">(</span><span class="s1">gt_centroids_list</span><span class="s3">) </span><span class="s2">if </span><span class="s1">gt_centroids_list </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">))</span>
    <span class="s1">all_det_world </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">(</span><span class="s1">detected_centroids_list</span><span class="s3">) </span><span class="s2">if </span><span class="s1">detected_centroids_list </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">))</span>
    <span class="s1">gt_count</span><span class="s3">, </span><span class="s1">det_count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">all_gt_world</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">all_det_world</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">gt_count </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">det_count </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">gt_count</span><span class="s3">, </span><span class="s1">det_count</span><span class="s3">, </span><span class="s5">0.0</span>

    <span class="s1">transform_inv </span><span class="s3">= ~</span><span class="s1">transform</span>
    <span class="s1">all_gt_px </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">transform_inv </span><span class="s3">* </span><span class="s1">pt </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">all_gt_world</span><span class="s3">])</span>
    <span class="s1">all_det_px </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">transform_inv </span><span class="s3">* </span><span class="s1">pt </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">all_det_world</span><span class="s3">])</span>
    <span class="s1">dist </span><span class="s3">= </span><span class="s1">pairwise_distances</span><span class="s3">(</span><span class="s1">all_gt_px</span><span class="s3">, </span><span class="s1">all_det_px</span><span class="s3">)</span>
    <span class="s1">row_ind</span><span class="s3">, </span><span class="s1">col_ind </span><span class="s3">= </span><span class="s1">linear_sum_assignment</span><span class="s3">(</span><span class="s1">dist</span><span class="s3">)</span>
    <span class="s1">matched </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">dist</span><span class="s3">[</span><span class="s1">r</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] &lt; </span><span class="s1">buffer_radius </span><span class="s2">for </span><span class="s1">r</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">row_ind</span><span class="s3">, </span><span class="s1">col_ind</span><span class="s3">))</span>

    <span class="s1">union </span><span class="s3">= </span><span class="s1">gt_count </span><span class="s3">+ </span><span class="s1">det_count </span><span class="s3">- </span><span class="s1">matched</span>
    <span class="s1">iou </span><span class="s3">= </span><span class="s1">matched </span><span class="s3">/ </span><span class="s1">union </span><span class="s2">if </span><span class="s1">union </span><span class="s3">&gt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">0.0</span>
    <span class="s2">if </span><span class="s1">det_count </span><span class="s3">&gt; </span><span class="s1">gt_count</span><span class="s3">:</span>
        <span class="s1">iou </span><span class="s3">*= (</span><span class="s1">gt_count </span><span class="s3">/ </span><span class="s1">det_count</span><span class="s3">)</span>
    <span class="s1">count_acc </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gt_count </span><span class="s3">- </span><span class="s1">det_count</span><span class="s3">) / </span><span class="s1">max</span><span class="s3">(</span><span class="s1">gt_count</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s1">final_score </span><span class="s3">= </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">count_acc </span><span class="s3">+ </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">iou </span><span class="s0"># Adjust final score calculation as needed.</span>
    <span class="s2">return </span><span class="s1">iou</span><span class="s3">, </span><span class="s1">gt_count</span><span class="s3">, </span><span class="s1">det_count</span><span class="s3">, </span><span class="s1">final_score</span>

<span class="s0"># Optimization with Optuna objective. Adjust hyperparameter ranges as needed.</span>
<span class="s2">def </span><span class="s1">objective</span><span class="s3">(</span><span class="s1">trial</span><span class="s3">, </span><span class="s1">enable_visuals</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">gamma </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_float</span><span class="s3">(</span><span class="s4">&quot;gamma&quot;</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">)</span>
    <span class="s1">sigma </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_float</span><span class="s3">(</span><span class="s4">&quot;sigma&quot;</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">)</span>
    <span class="s1">threshold_type </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_categorical</span><span class="s3">(</span><span class="s4">&quot;threshold_type&quot;</span><span class="s3">, [</span><span class="s4">&quot;otsu&quot;</span><span class="s3">])</span>
    <span class="s1">erosion_disk </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_int</span><span class="s3">(</span><span class="s4">&quot;erosion_disk&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">dilation_disk </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_int</span><span class="s3">(</span><span class="s4">&quot;dilation_disk&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
    <span class="s1">min_dist_frac </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_float</span><span class="s3">(</span><span class="s4">&quot;min_distance_fraction&quot;</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">)</span>
    <span class="s1">h_minima_frac </span><span class="s3">= </span><span class="s1">trial</span><span class="s3">.</span><span class="s1">suggest_float</span><span class="s3">(</span><span class="s4">&quot;h_minima_fraction&quot;</span><span class="s3">, </span><span class="s5">0.005</span><span class="s3">, </span><span class="s5">0.4</span><span class="s3">)</span>
    <span class="s1">buffer_radius </span><span class="s3">= </span><span class="s5">49</span>

    <span class="s1">batch_scores </span><span class="s3">= []</span>
    <span class="s1">matched_gt_total</span><span class="s3">, </span><span class="s1">gt_total</span><span class="s3">, </span><span class="s1">det_total </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span>

    <span class="s2">for </span><span class="s1">idx</span><span class="s3">, (</span><span class="s1">raster_path</span><span class="s3">, </span><span class="s1">gt_path</span><span class="s3">) </span><span class="s2">in </span><span class="s1">tqdm</span><span class="s3">(</span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">batch_files</span><span class="s3">), </span><span class="s1">total</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">batch_files</span><span class="s3">), </span><span class="s1">desc</span><span class="s3">=</span><span class="s4">&quot;Processing batches&quot;</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">raster_path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">() </span><span class="s2">or not </span><span class="s1">gt_path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">():</span>
            <span class="s2">continue</span>
        <span class="s1">gt </span><span class="s3">= </span><span class="s1">load_ground_truth</span><span class="s3">(</span><span class="s1">gt_path</span><span class="s3">, </span><span class="s1">raster_path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">gt </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">elevation_map</span><span class="s3">, </span><span class="s1">transform_img</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">load_raster</span><span class="s3">(</span><span class="s1">raster_path</span><span class="s3">)</span>
        <span class="s1">det </span><span class="s3">= </span><span class="s1">apply_segmentation</span><span class="s3">(</span><span class="s1">raster_path</span><span class="s3">, </span><span class="s1">gamma</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">threshold_type</span><span class="s3">, </span><span class="s1">erosion_disk</span><span class="s3">, </span><span class="s1">dilation_disk</span><span class="s3">, </span><span class="s1">min_dist_frac</span><span class="s3">, </span><span class="s1">h_minima_frac</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">det </span><span class="s2">is None or </span><span class="s1">len</span><span class="s3">(</span><span class="s1">det</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;Batch </span><span class="s2">{</span><span class="s1">idx </span><span class="s3">+ </span><span class="s5">1</span><span class="s2">}</span><span class="s4">: no detections.&quot;</span><span class="s3">)</span>
            <span class="s2">continue</span>
        <span class="s1">iou</span><span class="s3">, </span><span class="s1">gt_count</span><span class="s3">, </span><span class="s1">det_count</span><span class="s3">, </span><span class="s1">score </span><span class="s3">= </span><span class="s1">compute_global_iou</span><span class="s3">([</span><span class="s1">gt</span><span class="s3">], [</span><span class="s1">det</span><span class="s3">], </span><span class="s1">transform_img</span><span class="s3">, </span><span class="s1">buffer_radius</span><span class="s3">)</span>
        <span class="s1">batch_scores</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">score</span><span class="s3">)</span>
        <span class="s1">gt_total </span><span class="s3">+= </span><span class="s1">gt_count</span>
        <span class="s1">det_total </span><span class="s3">+= </span><span class="s1">det_count</span>

        <span class="s1">transform_inv </span><span class="s3">= ~</span><span class="s1">transform_img</span>
        <span class="s1">gt_px </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">transform_inv </span><span class="s3">* </span><span class="s1">pt </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">gt</span><span class="s3">])</span>
        <span class="s1">det_px </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">transform_inv </span><span class="s3">* </span><span class="s1">pt </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">det</span><span class="s3">])</span>
        <span class="s1">dist_matrix </span><span class="s3">= </span><span class="s1">pairwise_distances</span><span class="s3">(</span><span class="s1">gt_px</span><span class="s3">, </span><span class="s1">det_px</span><span class="s3">)</span>
        <span class="s1">row_ind</span><span class="s3">, </span><span class="s1">col_ind </span><span class="s3">= </span><span class="s1">linear_sum_assignment</span><span class="s3">(</span><span class="s1">dist_matrix</span><span class="s3">)</span>
        <span class="s1">matched_pairs </span><span class="s3">= [(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">c</span><span class="s3">) </span><span class="s2">for </span><span class="s1">r</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">row_ind</span><span class="s3">, </span><span class="s1">col_ind</span><span class="s3">) </span><span class="s2">if </span><span class="s1">dist_matrix</span><span class="s3">[</span><span class="s1">r</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] &lt; </span><span class="s1">buffer_radius</span><span class="s3">]</span>
        <span class="s1">matched_gt_total </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">({</span><span class="s1">r </span><span class="s2">for </span><span class="s1">r</span><span class="s3">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">matched_pairs</span><span class="s3">})</span>

    <span class="s1">final_score </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">batch_scores</span><span class="s3">) </span><span class="s2">if </span><span class="s1">batch_scores </span><span class="s2">else </span><span class="s5">0.0</span>

    <span class="s2">if </span><span class="s1">gt_total </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">global_iou </span><span class="s3">= </span><span class="s1">matched_gt_total </span><span class="s3">/ (</span><span class="s1">gt_total </span><span class="s3">+ </span><span class="s1">det_total </span><span class="s3">- </span><span class="s1">matched_gt_total</span><span class="s3">)</span>
        <span class="s1">global_count_acc </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gt_total </span><span class="s3">- </span><span class="s1">det_total</span><span class="s3">) / </span><span class="s1">max</span><span class="s3">(</span><span class="s1">gt_total</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">global_final_score </span><span class="s3">= </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">global_count_acc </span><span class="s3">+ </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">global_iou</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">\n </span><span class="s4">Global Final Score: </span><span class="s2">{</span><span class="s1">global_final_score</span><span class="s2">:</span><span class="s4">.3f</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot; Global IoU: </span><span class="s2">{</span><span class="s1">global_iou</span><span class="s2">:</span><span class="s4">.3f</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot; Global Count Accuracy: </span><span class="s2">{</span><span class="s1">global_count_acc</span><span class="s2">:</span><span class="s4">.3f</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot; Total Ground Truth: </span><span class="s2">{</span><span class="s1">gt_total</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot; Total Detections: </span><span class="s2">{</span><span class="s1">det_total</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">global_final_score </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\n </span><span class="s4">No ground truth points found across batches.&quot;</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">global_final_score</span>

<span class="s0"># Run optimization</span>
<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">&quot;__main__&quot;</span><span class="s3">:</span>
    <span class="s1">study </span><span class="s3">= </span><span class="s1">optuna</span><span class="s3">.</span><span class="s1">create_study</span><span class="s3">(</span><span class="s1">direction</span><span class="s3">=</span><span class="s4">&quot;maximize&quot;</span><span class="s3">, </span><span class="s1">study_name</span><span class="s3">=</span><span class="s4">&quot;per_batch_opt&quot;</span><span class="s3">)</span>
    <span class="s1">study</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">trial</span><span class="s3">: </span><span class="s1">objective</span><span class="s3">(</span><span class="s1">trial</span><span class="s3">, </span><span class="s1">enable_visuals</span><span class="s3">=</span><span class="s2">True</span><span class="s3">), </span><span class="s1">n_trials</span><span class="s3">=</span><span class="s5">500</span><span class="s3">) </span><span class="s0"># Adjust number of trials as needed.</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot; Best params:&quot;</span><span class="s3">, </span><span class="s1">study</span><span class="s3">.</span><span class="s1">best_params</span><span class="s3">)</span>
</pre>
</body>
</html>